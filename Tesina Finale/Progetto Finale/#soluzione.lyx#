#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{listings,xcolor,courier,bookmark}
\usepackage{listingsutf8}
\definecolor{darkblue}{named}{blue}
\definecolor{darkred}{named}{red}
\definecolor{grau}{named}{gray}
\let\Righttorque\relax
\lstset{
captionpos=b,
commentstyle=\color[rgb]{0.133,0.545,0.133},
keywordstyle=\color{darkblue},
stringstyle=\color{darkred},
extendedchars=true,
basicstyle=\small\ttfamily,
showstringspaces=false,
tabsize=2,
numbers=left,
numberstyle=\tiny,
breakautoindent  = true,
breakindent      = 2em,
breaklines       = true,
postbreak        = ,
prebreak         = \raisebox{-.8ex}[0ex][0ex]{\Righttorque},
showspaces=false, 
showtabs=false, 
showstringspaces=false,
language=VHDL,
frame=single,
morecomment=[s]{--}
}


\renewcommand*{\lstlistingname}{Codice Componente}


\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead{} 
\fancyfoot{} 

\fancyhead[RO,LE]{\bfseries \leftmark}
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,CE]{Tesina in Sistemi embedded}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\date{}
\cfoot{}

\usetikzlibrary{matrix,calc}

%isolated term
%#1 - Optional. Space between node and grouping line. Default=0
%#2 - node
%#3 - filling color
\newcommand{\implicantsol}[3][0]{
    \draw[rounded corners=3pt, fill=#3, opacity=0.3] ($(#2.north west)+(135:#1)$) rectangle ($(#2.south east)+(-45:#1)$);
    }


%internal group
%#1 - Optional. Space between node and grouping line. Default=0
%#2 - top left node
%#3 - bottom right node
%#4 - filling color
\newcommand{\implicant}[4][0]{
    \draw[rounded corners=3pt, fill=#4, opacity=0.3] ($(#2.north west)+(135:#1)$) rectangle ($(#3.south east)+(-45:#1)$);
    }

%group lateral borders
%#1 - Optional. Space between node and grouping line. Default=0
%#2 - top left node
%#3 - bottom right node
%#4 - filling color
\newcommand{\implicantcostats}[4][0]{
    \draw[rounded corners=3pt, fill=#4, opacity=0.3] ($(rf.east |- #2.north)+(90:#1)$)-| ($(#2.east)+(0:#1)$) |- ($(rf.east |- #3.south)+(-90:#1)$);
    \draw[rounded corners=3pt, fill=#4, opacity=0.3] ($(cf.west |- #2.north)+(90:#1)$) -| ($(#3.west)+(180:#1)$) |- ($(cf.west |- #3.south)+(-90:#1)$);
}

%group top-bottom borders
%#1 - Optional. Space between node and grouping line. Default=0
%#2 - top left node
%#3 - bottom right node
%#4 - filling color
\newcommand{\implicantdaltbaix}[4][0]{
    \draw[rounded corners=3pt, fill=#4, opacity=0.3] ($(cf.south -| #2.west)+(180:#1)$) |- ($(#2.south)+(-90:#1)$) -| ($(cf.south -| #3.east)+(0:#1)$);
    \draw[rounded corners=3pt, fill=#4, opacity=0.3] ($(rf.north -| #2.west)+(180:#1)$) |- ($(#3.north)+(90:#1)$) -| ($(rf.north -| #3.east)+(0:#1)$);
}

%group corners
%#1 - Optional. Space between node and grouping line. Default=0
%#2 - filling color
\newcommand{\implicantcantons}[2][0]{
    \draw[rounded corners=3pt, opacity=.3] ($(rf.east |- 0.south)+(-90:#1)$) -| ($(0.east |- cf.south)+(0:#1)$);
    \draw[rounded corners=3pt, opacity=.3] ($(rf.east |- 8.north)+(90:#1)$) -| ($(8.east |- rf.north)+(0:#1)$);
    \draw[rounded corners=3pt, opacity=.3] ($(cf.west |- 2.south)+(-90:#1)$) -| ($(2.west |- cf.south)+(180:#1)$);
    \draw[rounded corners=3pt, opacity=.3] ($(cf.west |- 10.north)+(90:#1)$) -| ($(10.west |- rf.north)+(180:#1)$);
    \fill[rounded corners=3pt, fill=#2, opacity=.3] ($(rf.east |- 0.south)+(-90:#1)$) -|  ($(0.east |- cf.south)+(0:#1)$) [sharp corners] ($(rf.east |- 0.south)+(-90:#1)$) |-  ($(0.east |- cf.south)+(0:#1)$) ;
    \fill[rounded corners=3pt, fill=#2, opacity=.3] ($(rf.east |- 8.north)+(90:#1)$) -| ($(8.east |- rf.north)+(0:#1)$) [sharp corners] ($(rf.east |- 8.north)+(90:#1)$) |- ($(8.east |- rf.north)+(0:#1)$) ;
    \fill[rounded corners=3pt, fill=#2, opacity=.3] ($(cf.west |- 2.south)+(-90:#1)$) -| ($(2.west |- cf.south)+(180:#1)$) [sharp corners]($(cf.west |- 2.south)+(-90:#1)$) |- ($(2.west |- cf.south)+(180:#1)$) ;
    \fill[rounded corners=3pt, fill=#2, opacity=.3] ($(cf.west |- 10.north)+(90:#1)$) -| ($(10.west |- rf.north)+(180:#1)$) [sharp corners] ($(cf.west |- 10.north)+(90:#1)$) |- ($(10.west |- rf.north)+(180:#1)$) ;
}

%Empty Karnaugh map 4x4
\newenvironment{Karnaugh}%
{
\begin{tikzpicture}[baseline=(current bounding box.north),scale=0.8]
\draw (0,0) grid (4,4);
\draw (0,4) -- node [pos=0.7,above right,anchor=south west] {zv} node [pos=0.7,below left,anchor=north east] {xy} ++(135:1);
%
\matrix (mapa) [matrix of nodes,
        column sep={0.8cm,between origins},
        row sep={0.8cm,between origins},
        every node/.style={minimum size=0.3mm},
        anchor=8.center,
        ampersand replacement=\&] at (0.5,0.5)
{
                       \& |(c00)| 00         \& |(c01)| 01         \& |(c11)| 11         \& |(c10)| 10         \& |(cf)| \phantom{00} \\
|(r00)| 00             \& |(0)|  \phantom{0} \& |(1)|  \phantom{0} \& |(3)|  \phantom{0} \& |(2)|  \phantom{0} \&                     \\
|(r01)| 01             \& |(4)|  \phantom{0} \& |(5)|  \phantom{0} \& |(7)|  \phantom{0} \& |(6)|  \phantom{0} \&                     \\
|(r11)| 11             \& |(12)| \phantom{0} \& |(13)| \phantom{0} \& |(15)| \phantom{0} \& |(14)| \phantom{0} \&                     \\
|(r10)| 10             \& |(8)|  \phantom{0} \& |(9)|  \phantom{0} \& |(11)| \phantom{0} \& |(10)| \phantom{0} \&                     \\
|(rf) | \phantom{00}   \&                    \&                    \&                    \&                    \&                     \\
};
}%
{
\end{tikzpicture}
}

%Empty Karnaugh map 2x4
\newenvironment{Karnaughvuit}%
{
\begin{tikzpicture}[baseline=(current bounding box.north),scale=0.8]
\draw (0,0) grid (4,2);
\draw (0,2) -- node [pos=0.7,above right,anchor=south west] {bc} node [pos=0.7,below left,anchor=north east] {a} ++(135:1);
%
\matrix (mapa) [matrix of nodes,
        column sep={0.8cm,between origins},
        row sep={0.8cm,between origins},
        every node/.style={minimum size=0.3mm},
        anchor=4.center,
        ampersand replacement=\&] at (0.5,0.5)
{
                      \& |(c00)| 00         \& |(c01)| 01         \& |(c11)| 11         \& |(c10)| 10         \& |(cf)| \phantom{00} \\
|(r00)| 0             \& |(0)|  \phantom{0} \& |(1)|  \phantom{0} \& |(3)|  \phantom{0} \& |(2)|  \phantom{0} \&                     \\
|(r01)| 1             \& |(4)|  \phantom{0} \& |(5)|  \phantom{0} \& |(7)|  \phantom{0} \& |(6)|  \phantom{0} \&                     \\
|(rf) | \phantom{00}  \&                    \&                    \&                    \&                    \&                     \\
};
}%
{
\end{tikzpicture}
}

%Empty Karnaugh map 2x2
\newenvironment{Karnaughquatre}%
{
\begin{tikzpicture}[baseline=(current bounding box.north),scale=0.8]
\draw (0,0) grid (2,2);
\draw (0,2) -- node [pos=0.7,above right,anchor=south west] {b} node [pos=0.7,below left,anchor=north east] {a} ++(135:1);
%
\matrix (mapa) [matrix of nodes,
        column sep={0.8cm,between origins},
        row sep={0.8cm,between origins},
        every node/.style={minimum size=0.3mm},
        anchor=2.center,
        ampersand replacement=\&] at (0.5,0.5)
{
          \& |(c00)| 0          \& |(c01)| 1  \\
|(r00)| 0 \& |(0)|  \phantom{0} \& |(1)|  \phantom{0} \\
|(r01)| 1 \& |(2)|  \phantom{0} \& |(3)|  \phantom{0} \\
};
}%
{
\end{tikzpicture}
}

%Defines 8 or 16 values (0,1,X)
\newcommand{\contingut}[1]{%
\foreach \x [count=\xi from 0]  in {#1}
     \path (\xi) node {\x};
}

%Places 1 in listed positions
\newcommand{\minterms}[1]{%
    \foreach \x in {#1}
        \path (\x) node {1};
}

%Places 0 in listed positions
\newcommand{\maxterms}[1]{%
    \foreach \x in {#1}
        \path (\x) node {0};
}

%Places X in listed positions
\newcommand{\indeterminats}[1]{%
    \foreach \x in {#1}
        \path (\x) node {X};
}
\end_preamble
\use_default_options true
\master Tesina.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation 0bp
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Scelte Progettuali
\end_layout

\begin_layout Subsection
Architettura del sistema e topologia della rete
\end_layout

\begin_layout Standard
Si è sviluppato il software supponendo che il sistema sia composto da un
 numero n di nodi che differiscono esclusivamente dal fatto di poter assumere
 il ruolo di Master o Slave nelle comunicazioni sui bus.
 Ogni nodo è realizzato utilizzando una board 
\emph on
STM32F3 Discovery.

\emph default
 Nel sistema sono 
\begin_inset Quotes eld
\end_inset

idealmente
\begin_inset Quotes erd
\end_inset

 presenti un bus 
\emph on
I2C
\emph default
, un bus 
\emph on
SPI
\emph default
 e un bus 
\emph on
CAN
\emph default
 ai quali tutti i nodi sono connessi.
 Ogni nodo, inoltre, è connesso 
\begin_inset Quotes eld
\end_inset


\emph on
punto punto
\emph default

\begin_inset Quotes erd
\end_inset

 ad un altro nodo del sistema utilizzando una periferica UART.
\end_layout

\begin_layout Subsubsection
Arbitraggio dei bus
\end_layout

\begin_layout Standard
I bus utilizzati offrono diverse possiblità ai nodi per 
\begin_inset Quotes eld
\end_inset

interfacciarsi
\begin_inset Quotes erd
\end_inset

 agli stessi:
\end_layout

\begin_layout Itemize

\series bold
I2C
\series default
: è un bus che permette nativamente un arbitraggio sia 
\emph on
SingleMaster-Multislave
\emph default
 che 
\emph on
Multimaster.
 
\emph default
Nel primo caso un solo nodo
\series bold
 
\series default
(master) può prendere possesso del bus e iniziare trasmissioni
\backslash
ricezioni verso
\backslash
da altri nodi, nel secondo caso più nodi possono gestire il bus e prendere
 iniziativa di trasferimento
\backslash
ricezione.
 Nella soluzione realizzata si è scelto di realizzare lo schema 
\series bold
\emph on
Multimaster
\series default
.
 
\emph default
Specificamente nella gestione delle comunicazioni fra i nodi si è scelto
 di far si che il nodo si comporti da 
\bar under
master quando effettua una trasmissione e da slave quando effettua una ricezione
\bar default
.
 Questo implica che nella trasmissione il nodo è conscio del nodo al quale
 sta trasmettendo, mentre non lo è nella ricezione.
\end_layout

\begin_layout Itemize

\series bold
SPI
\series default
: è un bus nativamente 
\emph on
SingleMaster-Multislave.
 
\emph default
Le board STM32 permettono di realizzare una soluzione 
\emph on
multimaster 
\emph default
che tuttavia non risulta utile per il numero di fili necessari se il numero
 di nodi è superiore a 2.
 Si è scelto di realizzare dunque la soluzione 
\series bold
\emph on
multislave
\series default
 
\emph default
con un solo nodo che funge da master e gestisce k slave con k segnali di
 Salve Select che permettono di effettuare l'arbitraggio.
 Il master seleziona lo slave con il quale comunicare sia in caso di tramissione
 che ricezione.
\end_layout

\begin_layout Itemize

\series bold
CAN
\series default
: bus nativamente ed esclusivamente 
\series bold
multimaster
\series default
.
 Viene utilizzato naturalmente in questa configurazione.
\end_layout

\begin_layout Standard
Si noti che la scelta sulla comunicazione di I2C differisce solo a livello
 software,è possibilie trasmettere e riceve in modalità master.
 Si è scelta questa soluzione per rendere uniforme il comportamento delle
 periferiche dei nodi nelle trasmissioni.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/connessioni sul bus.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Connessione dei nodi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Modalità di Trasmissione
\end_layout

\begin_layout Standard
La trasmissione può essere effettuata con tre modalità differenti: 
\emph on
unicast
\emph default
, 
\emph on
multicast
\emph default
 e 
\emph on
broadcast
\emph default
.
\end_layout

\begin_layout Itemize
Unicast: il nodo manda il messaggio ad un solo nodo destinatario.
 E' possibile realizzare questa modalità di trasmissione su tutti e tre
 i bus.
\end_layout

\begin_layout Itemize
Multicast: il nodo manda il messaggio ad un insieme di bord associata ad
 un 
\begin_inset Quotes eld
\end_inset

gruppo
\begin_inset Quotes erd
\end_inset

.
 La trasmissione in questa modalità è disponibile solo sul bus CAN.
 Se si volesse realizzare sugli altri bus sarebbe necessario implementare
 una politica di trasmissione multi-unicast ma non si è ritenuto necessario
 data la disponibilità di CAN.
\end_layout

\begin_layout Itemize
Broadcast: il nodo manda il mesaggio a tutti i nodi collegati al bus.
 La trasmissione in questa modalità è disponibile solo sul bus CAN.
\end_layout

\begin_layout Subsubsection
Gestione degli indirizzi
\end_layout

\begin_layout Standard
Ogni periferica è dotata di una gestione degli indirizzi differente e può
 essere configurata indipendentemente da come sono settate le altre, ma
 ogni periferica risponde ad 
\begin_inset Quotes eld
\end_inset

spazio degli indirizzi unico
\begin_inset Quotes erd
\end_inset

.
 Per le tramissioni sul bus si è scelto che ad ogni nodo siano associati
 due indirizzi:
\end_layout

\begin_layout Enumerate

\series bold
NODE ADDRESS
\series default
: indirizzo univoco del nodo.
 Utilizzato per effettuare comunicazioni unicast.
\end_layout

\begin_layout Enumerate

\series bold
GROUP ADDRESS
\series default
: inidirizzo non univoco e condiviso fra tutti i nodi appartemente ad un
 determinato gruppo.
 Permette di realizzare le comunicazioni multicast con CAN.
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/rete interconnessione.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gestione degli indirizzi
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

Consideriamo che:
\end_layout

\begin_layout Itemize

\series bold
I2C
\series default
 permette di associare alla periferica un indirizzo di 
\emph on
\bar under
lunghezza massima 10 bit.

\bar default
 
\emph default
Per effettuare la ricezione del messaggio è necessario che tutti i bit del
 campo address dello stesso (o una parte di essi non mascherati se si utilizzano
 maschere) corripondano all'indirizzo della periferica.
\end_layout

\begin_layout Itemize

\series bold
SPI
\series default
 non utilizza indirizzi per identificare i nodi ma collegamenti fisici.
\end_layout

\begin_layout Itemize

\series bold
CAN
\series default
 non associa un indirizzo univoco al nodo poichè il messaggio è inviato
 sempre in broadcast e spetta al singolo nodo stabilire se è interessato
 o meno al messaggio mediante dei filtri.
 Questi filitri possono operare in due modalità: 
\emph on
mask
\emph default
 o 
\emph on
IDList.
 
\emph default
Nel primo caso, al filtro viene dato un ID ed una maschera da utiilizzare
 per confrontare i bit del campo ID del messaggio con il campo ID del filtro
 (i bit mascherati con 0 non vengono confrontati ma viene automaticamente
 dato matching), nel secodo caso invece ogni filtro corrisponde ad uno o
 piu ID (1 da 32bit o 2 da 16 bit) che devono 
\begin_inset Quotes eld
\end_inset

essere accettati
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Si utilizza questo meccanismo (IDList) per assegnare l'indirizzo del nodo
 sul bus CAN, prestando accortezza che nella fase di inizializzazione ogni
 periferica abbia un filtro con indirizzo univoco pari a quello associato
 ad I2C.
 Si è scelto di realizzare i gruppi con la modalità IDList e non mask per
 praticità e per poter avere un maggiore controllo sugli indirizzi da assegnare
 e totale libertà nel decidere quale nodo appartenga a quale gruppo.
 Dunque un nodo, per appartenere ad un gruppo, dovrà specificare il GROUP_ADDRES
S nel campo id di un filtro.
 Un filtro, in questa modalità, può rappresentare un singolo ID da 32 bit
 oppure due ID diversi da 16.
 Dato che il nostro spazio degli indirizzi è limitato superiormente dall'inidiri
zzo di I2C a 10 bit, utilizzeremo un unico filtro contenente due ID (NODE_ADDRES
S e GROUP_ADDRESS) da 16 bit (i bit[15 10] saranno sempre nulli).
\end_layout

\begin_layout Standard
Essendo lo spazio degli indirizzi su 10, ed essendo condiviso fra nodi e
 gruppi, potremmo avere teoricamente:
\end_layout

\begin_layout Standard
numero_nodi+numero_gruppi = 
\begin_inset Formula $2^{10}.$
\end_inset

 Fra questi indizzi non possiamo però considerare:
\end_layout

\begin_layout Itemize
0x0000000000: indirizzo generical call su I2C che potrebbe essere utilizzato
 per effettuare broadcast.
 Si è scelto di non utilizare questo indirizzo e di non effettuare broadcast
 su I2C poichè non è presente ACK da parte degli slave che ricevono il messaggio.
 Ciò non lo differenzierebbe da CAN.
\end_layout

\begin_layout Itemize
0x0000000001: indirizzo scelto per realizzare una comunicazione broadcast
 su CAN facendo si che ogni nodo inserisca nella propria coda RX i messaggi
 con questo ID.
 Il meccanismo è stato realizzato aggiuggendo ad ogni nodo un ulteriore
 filtro con questo ID.
\end_layout

\begin_layout Subsection
Architettura Software
\end_layout

\begin_layout Subsubsection
Descrizione API
\end_layout

\begin_layout Standard
L'architettura software, come richiesto, è composta da due livelli.
 Il livello più alto astrae le seguenti primitive che vengono offerte all'applic
ativo, ovvero:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void CRC_Check(uint32_t * ReceivedFrame);
\end_layout

\begin_layout Plain Layout

uint8_t Receive_CRC(uint32_t * ReceivedData, uint8_t channel, uint16_t address);
\end_layout

\begin_layout Plain Layout

uint8_t Send_CRC(uint32_t * MSG,uint16_t address, uint8_t channel, uint8_t
 mode);
\end_layout

\begin_layout Plain Layout

void Configure_Peripheral(uint8_t peripheral, uint16_t nodeAddress, uint16_t
 groupAddress);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
\emph on
CRC_Check
\series default
\emph default
: prende in ingresso un puntatore al buffer contenente il messaggio ricevuto.
 Quest'ultimo è composto dal payload e dai due CRC di 32 bit calcolati dal
 nodo che ha trasmesso il messaggio.
 La funzione calcola i due CRC relativi al payload ricevuto e li confronta
 con quelli ricevuti, se sono uguali accende i led 10 e 3 di colore verde.
 Dopo aver calcolato i CRC ed effettuato il confronto sosostituisce i CRC
 presenti nel frame con quelli appena calcolati.
\end_layout

\begin_layout Itemize

\series bold
\emph on
Send_CRC
\series default
\emph default
: prende in ingresso un puntatore al buffer contenente il messaggio da trasmette
re, l'indirizzo del nodo destinazione (utilizzato solo da I2C, SPI e CAN),
 una maschera che indica su quali canali effettuare la trasmissione e la
 modalità di trasmissione.
 Nel precedente paragrafo è stato evidenziato che l'unico canale su cui
 è possibile effettuare una cominucazione in modalità multicast e broadcast
 risulti essere CAN.
 Se l'utente dovesse scegliere una modalità non compatibile ai canali selezionat
i la funzione ritornerà il valore -1, negando dunque la trasmissione, altrimenti
 ritorna una maschera indicante le periferiche sulle quali si è effettuata
 la trasmissione.
 Se la maschera dei canali in ingresso indica che l'invio debba essere effettuat
o su più canali questo avviene in maniera prettamente sequenziale.
 La trasmissione su una periferica non inizia se non è stato rilevato il
 completamento di quella precedente.
\end_layout

\begin_layout Itemize

\series bold
\emph on
Receive_CRC
\series default
\emph default
: prende in ingresso un puntatore al buffer che verrà utilizzato per salvare
 il messaggio ricevuto, una maschera che indica i canali sui quali effettuare
 la ricezione e il parametro address, utilizzato nel caso la trasmissione
 sia richiesta su SPI per effettuare il matching con il corrispondente segnale
 di Slave Select, la funzione restituisce la maschera indicante le periferiche
 sulle quali si è effettuata la ricezione.
 Tale operazione ha lo stesso comportamento adottato nella trasmissione.
 Avrebbe potuto aver senso, dato l'utilizzo degli interrupt, abilitare tutte
 le periferiche in ricezione e poi controllarne ciclicamente lo stato in
 Round Robin, ma non è stata seguita tale scelta perchè si suppone che tutte
 le periferiche ricevano dallo stesso nodo mentre si trovano all'interno
 della funzione di receive, quindi il comportamento ottenuto sarebbe stato
 il medesimo.
 Nel caso di utilizzo di più periferiche per la ricezione il messaggio viene
 sovrascritto a ogni nuova ricezione, ma il calcolo del CRC viene effettuato
 ad ogni singola intercettazione di un messaggio.
\end_layout

\begin_layout Itemize
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UART
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I2C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SPI
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CAN
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UNICAST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✓
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✓
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✓
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✓
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MULTICAST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✕
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✕
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✕
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✓
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BROADCAST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✕
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✕
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✕
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
✓
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Modalità di trasmissione
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
\emph on
Configure_Peripheral
\series default
\emph default
: prende in ingresso una maschera la quale indica le periferiche da configurare,
 l'indirizzo del nodo e del gruppo a cui appartiene il nodo, per poter inizializ
zare le periferiche CAN e I2C.
 Nel caso il nodo sia master allora la periferica SPI verrà configurata
 come tale, altrimenti come slave.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Graphics
	filename images/livelli.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Architettura Software
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il secondo livello è composto da tutti i driver implementati per l'inizializzazi
one e l'interfacciamento con le varie periferiche utilizzate.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Graphics
	filename images/includes.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Module view
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
CAN
\end_layout

\begin_layout Standard
Come già detto in precedenza, i filtri CAN sono stati impostati in modalità
 ID_LIST con scala a 16 bit.
 Viene assegnato dunque l'indirizzo del nodo ad IdHigh e l'indirizzo del
 gruppo ad IdLow.
 Segue il codice relativo a tale configurazione:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

sFilterConfig.FilterMode = CAN_FILTERMODE_IDLIST; 
\end_layout

\begin_layout Plain Layout

sFilterConfig.FilterScale = CAN_FILTERSCALE_16BIT;				   
\end_layout

\begin_layout Plain Layout

sFilterConfig.FilterIdHigh = nodeAddress<<5;								 
\end_layout

\begin_layout Plain Layout

sFilterConfig.FilterIdLow = groupAddress<<5;								
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Viene mostrato in seguito come viene costruito un Frame CAN A (si noti che
 è supportato anche il protocollo CAN B).
 E' necessario costruire l'header del messaggio specificando:
\end_layout

\begin_layout Enumerate
Standard CAN Identifier: identificativo del messaggio codificato su 11 bit
 secondo il protocollo CAN Standard.
\end_layout

\begin_layout Enumerate
Extended CAN Identifier: identificativo del messaggio codificato su 29 bit
 secondo il protocollo CAN Extended.
\end_layout

\begin_layout Enumerate
Tipo di messaggio da trasmettere.
\end_layout

\begin_layout Enumerate
Tipo di identificativo per il messaggio da trasmettere: 
\emph on
Standard
\emph default
 o 
\emph on
Extended
\emph default
.
\end_layout

\begin_layout Enumerate
Lunghezza in byte del messaggio da trasmettere.
 Può assumere un valore da 0 ad 8.
\end_layout

\begin_layout Enumerate
Timestamp acquisito all'avvio della trasmissione del Frame.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

TxHeader.StdId = address; 		
\end_layout

\begin_layout Plain Layout

TxHeader.ExtId = 0x00; 		
\end_layout

\begin_layout Plain Layout

TxHeader.RTR = CAN_RTR_DATA; 		
\end_layout

\begin_layout Plain Layout

TxHeader.IDE = CAN_ID_STD; 		
\end_layout

\begin_layout Plain Layout

TxHeader.DLC = 8; 		
\end_layout

\begin_layout Plain Layout

TxHeader.TransmitGlobalTime = DISABLE;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

HAL_CAN_AddTxMessage(&CanHandle, &TxHeader, CanTx_Frame, &TxMailbox);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Creiamo tanti frame affinché possiamo trasmettere tutto il contenuto di
 aTxBuffer ed aggiungiamo tale messaggio alla Mailbox di invio.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan) {
\end_layout

\begin_layout Plain Layout

	HAL_CAN_GetRxMessage(&CanHandle, CAN_RX_FIFO0, &RxHeader, CanRx_Frame);
\end_layout

\begin_layout Plain Layout

	if((RxHeader.RTR != CAN_RTR_DATA) ||  (RxHeader.IDE != CAN_ID_STD) ||(RxHeader.DLC
 != 8)){ 		
\end_layout

\begin_layout Plain Layout

		Error_Handler(); 	} 	
\end_layout

\begin_layout Plain Layout

	else{ 		
\end_layout

\begin_layout Plain Layout

		BSP_LED_On(LED5); 		
\end_layout

\begin_layout Plain Layout

		for(int k=0; k<8; k++){ 			
\end_layout

\begin_layout Plain Layout

			CAN_RxBuffer[rx_callback_count*8+k] = CanRx_Frame[k]; 	
\end_layout

\begin_layout Plain Layout

			} 	
\end_layout

\begin_layout Plain Layout

		}   
\end_layout

\begin_layout Plain Layout

	rx_callback_count++;
\end_layout

\begin_layout Plain Layout

    if(rx_callback_count == CAN_CALLBACK_COUNT){ 	  
\end_layout

\begin_layout Plain Layout

		uint32_t ReceivedData[FRAME_SIZE]; 	  
\end_layout

\begin_layout Plain Layout

		Frame8to32(CAN_RxBuffer, ReceivedData); 	  
\end_layout

\begin_layout Plain Layout

		CRC_Check(ReceivedData); }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Quando un messaggio CAN arriva al dispositivo viene attivata questa Callback
 che come prima operazione preleva il frame dalla mailbox e controlla con
 i campi del frame che il messaggio sia corretto, oltre a verificare l'
 integrità del messaggio con il CRC.
\end_layout

\begin_layout Subsubsection
I2C
\end_layout

\begin_layout Standard
Per quando riguarda I2C la parte importante riguarda l' assegnazione dell'
 indirizzo da dare alla periferica, come mostrato nel codice
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

hi2c2.Init.OwnAddress1 = nodeAddress;   
\end_layout

\begin_layout Plain Layout

hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_10BIT;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per la trasmissione semplicemente basta indicare chi contattare, cosa inviare
 e quanto grande sia questo dato.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

HAL_I2C_Master_Transmit_IT(&hi2c2, (uint16_t) address,(uint8_t*) aTxBuffer,
 BUFFER_SIZE)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come possiamo notare la board quando invia è master del bus.
\end_layout

\begin_layout Standard
Per quanto riguarda la ricezione, dato che essa avviene da slave, non va
 indicato alcun indirizzo.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

HAL_I2C_Slave_Receive_IT(&hi2c2, (uint8_t *)I2C_RxBuffer, BUFFER_SIZE)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
SPI
\end_layout

\begin_layout Standard
Per SPI riguardo alla configurazione non ci sono particolari riflessioni
 da fare.
 E' interessante notare il meccanismo necessario per indirizzare la comunicazion
e.
 La funzione Send_CRC prende come parametro di ingresso un indirizzo per
 indentificare il destinario, mentre SPI necessita di abilitare un pin per
 dare il segnale di SS.
 La funzione getSSPin dovrebbe dunque conoscere tutta la configurazione
 della rete ed effettuare la corrispondenza.
 Nel nostro caso, ai fini dell'applicativo di prova si è scelto di implementare
 uno STUB.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

uint16_t getSSPin(uint16_t address){ 	
\end_layout

\begin_layout Plain Layout

	return SPI_EN_OUTPUT_Pin; 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si noti che SPI prevede che il segnale di SS allo slave venga fornito mediante
 il PIN NSS della periferica.
 Quando NSS diviene low vuol dire che va abilitata la transazione con il
 master.
 Per evitare funzionamenti oscillanti del pin NSS nativo dell'STM, seguendo
 i consiglio della community ST e dopo vari test, si è scelto di ricreare
 il medesimo meccanismo utilizzando un GPIO opportunamente configurato in
 sostituzione del pin NSS.
 Dunque la gestione sarà software e non più hardware.
 Se il nodo è master sul bus allora, tramite un suo GPIO (necessario per
 realizzare il multislave) dovrà abbassare il sengale prima di iniziare
 la transazione, se il nodo è uno slave dovrà aspettare che il segnale SS
 (in lettura su un pin GPIO deciso da noi) diventi basso.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

#ifdef MASTER_BOARD 		
\end_layout

\begin_layout Plain Layout

uint16_t slaveSelectPin = getSSPin(address); 		
\end_layout

\begin_layout Plain Layout

HAL_GPIO_WritePin(SPI_EN_OUTPUT_GPIO_Port,slaveSelectPin , GPIO_PIN_RESET);
\end_layout

\begin_layout Plain Layout

#else 		
\end_layout

\begin_layout Plain Layout

while(HAL_GPIO_ReadPin(SPI_EN_OUTPUT_GPIO_Port, SPI_EN_INPUT_Pin) != GPIO_PIN_RE
SET){ 		} 	
\end_layout

\begin_layout Plain Layout

#endif /* MASTER_BOARD */
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
UART
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

huart2.Init.BaudRate = Baudrate;   
\end_layout

\begin_layout Plain Layout

huart2.Init.WordLength = UART_WORDLENGTH_8B;   
\end_layout

\begin_layout Plain Layout

huart2.Init.StopBits = UART_STOPBITS_1;   
\end_layout

\begin_layout Plain Layout

huart2.Init.Parity = UART_PARITY_NONE;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nella configurazione di UART è necessario indicare la velocità di comunicazione,
 la struttura del frame da inviare: il numero di bit per il dato, quanti
 bit di stop e se utilizzare il bit di parità.
\end_layout

\begin_layout Standard
Per la trasmissione non ci sono ulterioni note, mentre invece per la ricezione
 prima di effettare la prossima si attende che il pin RX non sia più utilizzato.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

while(HAL_UART_GetState(&huart2) == HAL_UART_STATE_BUSY_RX){ 				 			
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if (HAL_UART_Receive_IT(&huart2, (uint8_t *) UART_RxBuffer, BUFFER_SIZE)
 != HAL_OK) 					
\end_layout

\begin_layout Plain Layout

	Error_Handler(); 			
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
CRC
\end_layout

\begin_layout Standard
La periferica adibita a calcolare il CRC viene configurata in modo tale
 da utilizzare i polinomi descritti nella specifica
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_DISABLE; 	
\end_layout

\begin_layout Plain Layout

hcrc.Init.GeneratingPolynomial = CRC_Polynomial; 	
\end_layout

\begin_layout Plain Layout

hcrc.Init.CRCLength = CRC_POLYLENGTH_32B; 	
\end_layout

\begin_layout Plain Layout

hcrc.Init.DefaultInitValueUse = CRC_DefaultValue;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Abbiamo lasciato la possibilità di utilizzare un valore di inizializzazione
 nel caso in un successivo futuro questo dovesse essere richiesto.
\end_layout

\begin_layout Standard
Si noti che è necessario configuare due volte la periferica per utlizzare
 polinoi diversi.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

MX_CRC_Init(CRC_POLYNOMIAL_1, CRC_DEFAULTVALUE_1); 	
\end_layout

\begin_layout Plain Layout

uint32_t CRC32_1 = HAL_CRC_Calculate(&hcrc, (uint32_t *) ReceivedFrame,
 	PAYLOAD_SIZE);
\end_layout

\begin_layout Plain Layout

MX_CRC_Init(CRC_POLYNOMIAL_2, CRC_DEFAULTVALUE_2);
\end_layout

\begin_layout Plain Layout

uint32_t CRC32_2 = HAL_CRC_Calculate(&hcrc, (uint32_t *) ReceivedFrame,
 	PAYLOAD_SIZE);
\end_layout

\begin_layout Plain Layout

if (CRC32_1 != ReceivedFrame[CRC1_OFFSET]) 		
\end_layout

\begin_layout Plain Layout

	HAL_GPIO_WritePin(GPIOE, LED10_RED_Pin, GPIO_PIN_SET); 	
\end_layout

\begin_layout Plain Layout

else 		
\end_layout

\begin_layout Plain Layout

	HAL_GPIO_WritePin(GPIOE, LED7_GREEN_Pin, GPIO_PIN_SET);
\end_layout

\begin_layout Plain Layout

if (CRC32_2 != ReceivedFrame[CRC2_OFFSET]) 		
\end_layout

\begin_layout Plain Layout

	HAL_GPIO_WritePin(GPIOE, LED3_RED_Pin, GPIO_PIN_SET); 	
\end_layout

\begin_layout Plain Layout

else 		
\end_layout

\begin_layout Plain Layout

	HAL_GPIO_WritePin(GPIOE, LED6_GREEN_Pin, GPIO_PIN_SET);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alla ricezione di un messaggio vengono prelevati i valori dei CRC da una
 posizione stabilita nel messaggio (essendo il messaggio di dimensione fissa),
 si rieffettua il calcolo con i polinomi stabili e confrontati se sono identici
 con quelli ricevuti.
\end_layout

\begin_layout Subsection
Applicativo Utente
\end_layout

\begin_layout Standard
Per testare le corretto funzionamento dell'architetture sottostande e eseguire
 una limitata simulazione dei sistema è stato realizano un applicativo che
 permettere la comunicazione fra un master e uno slave del sistema.
 L'algoritmo eseguito ciclicamente è il seguente:
\end_layout

\begin_layout Enumerate
Ricezione Messaggio
\end_layout

\begin_layout Enumerate
Ricalcolo, confronto CRC e sostituzione dei CRC nel messaggio
\end_layout

\begin_layout Enumerate
Invio del nuovo Messaggio
\end_layout

\begin_layout Standard
Nell'applicativo la differenza fra nodo Master e nodo slave è che il primo
 inizia il suo workflow con un init con valori random del messaggio da mandare,
 un calcolo dei due CRC, imapacchettamento del messaggio e una successiva
 Send allo slave.
 Segue uno schema del flusso:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/seq.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Worklow test Main
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il main test è facilmente configurabile in:
\end_layout

\begin_layout Itemize
Dimensione del messaggio da inviare: Il messaggio viene generato casualmente
 ad un ciclo for iniziale.
 Per settarne la dimensione è sufficiente definire la dimensione del PAYLOAD_SIZ
E nel main.h indicando come valore (numero_byte_da_inviare*4).
\end_layout

\begin_layout Itemize
Periferiche sul quale effettuare la tramissione:
\end_layout

\begin_deeper
\begin_layout Itemize
Ogni periferica è codifica da un oppurtuna define [UART_MODE, I2C_MODE,SPI_MODE]
\end_layout

\begin_layout Itemize
Il parametro SERIAL_SELECT di ingresso della 
\emph on
Sand_CRC
\emph default
 può essere settato tramite #define metendo in 
\emph on
OR bitwise 
\emph default
| le periferiche se si vogliono usare.
 ES.
 [UART_MODE | I2C_MODE] per utilizzare UART e I2C
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
La modalità CAN va provata in maniera esclusiva, in quanto il componente
 è configurato in LOOP_BACK (allacciato su se stesso) e inserendo come indirizzo
 della sand uno dei valori (NODE_ADDRESS e GROUP_ADDRESS) passati alla funzione
 di configurazione delle periferiche.
 Inoltre deve essere effuttuata solo la Sand altrimenti la recive rimarrebbe
 bloccata in attesa di reicezione.
 Il codice per un eventuale funzionamento non in looback è comunque commentato
 nella receive.
 Le altre periferiche possono essere utilizzate in contemporanea.
 SPI potrebbe generare malfunzionamenti dovuti alla connessione, UART e
 I2C risultano stabili.
\end_layout

\begin_layout Subsubsection
Connessioni fische broad
\end_layout

\begin_layout Standard
Si riporta in seguito la connessione delle board utilizzate nell'attuale
 configurazione dei driver.
 Per SPI è necessario esclusivamente che PA8 sul master con PA9 dello slave
 e non vicevesa.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Graphics
	filename images/UART.PNG

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
UART
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Graphics
	filename images/I2C_pin.PNG

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
I2C
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\begin_inset Graphics
	filename images/SPI_pin.PNG

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
SPI
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
