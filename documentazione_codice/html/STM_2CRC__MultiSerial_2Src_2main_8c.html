<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Codice Sistemi Embedded: /media/saverio/OS/Users/Saverio/Desktop/SE/git/codici_da_mandare/STM/CRC_MultiSerial/Src/main.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Codice Sistemi Embedded
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_23585ebff4fc9388889d7a080054297c.html">codici_da_mandare</a></li><li class="navelem"><a class="el" href="dir_a8c86160f73a2bca26650231adf755ec.html">STM</a></li><li class="navelem"><a class="el" href="dir_4cb452ac534268092a8c6bcd420cfb79.html">CRC_MultiSerial</a></li><li class="navelem"><a class="el" href="dir_c806e9e13d6d0864b99fa97e7b793f97.html">Src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">main.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>programma main che permette a board di comunicare utilizzando i seguenti protocolli: <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a>, SPI, I2C CAN. La board definita come Master calcola due CRC di un messaggio, li accoda ai frame da trasmettere e procede alla trasmissione sui canali selezionati.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>programma main che permette a board di comunicare utilizzando i seguenti protocolli: <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a>, SPI, I2C CAN. La board definita come Master calcola due CRC di un messaggio, li accoda ai frame da trasmettere e procede alla trasmissione sui canali selezionati. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a766b4f823b76fe57002327f6df0a234d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766b4f823b76fe57002327f6df0a234d">&#9670;&nbsp;</a></span>Configure_Peripheral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Configure_Peripheral </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>peripheral</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nodeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>groupAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configura le periferiche affinchè possano ricevere ed inviare messaggi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>valore che indica quale periferiche abilitare </td></tr>
    <tr><td class="paramname">nodeAddress</td><td>indirizzo del nodo da contattare, utilizzato se la comunicazione lo prevede </td></tr>
    <tr><td class="paramname">groupAddress</td><td>indirizzo del gruppo da contattare, utilizzato se la comunicazione lo prevede </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8b91edf48d948475e90024c60b8d13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b91edf48d948475e90024c60b8d13a">&#9670;&nbsp;</a></span>CRC_Check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CRC_Check </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ReceivedFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ricalcola i due CRC del messaggio e li confronta con quelli ricevuti. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ReceivedFrame</td><td>messaggio ricevuto </td></tr>
  </table>
  </dd>
</dl>
<p>Reinserisce i due CRC ricalcolati dal messaggio alla fine dello stesso </p>

</div>
</div>
<a id="a94b4225bd565c3f21d418e13cab1b590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b4225bd565c3f21d418e13cab1b590">&#9670;&nbsp;</a></span>Frame32to8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Frame32to8 </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>in_buffer32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>out_buffer8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converte un frame da un formato uint32_t ad uno uint8_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_buffer32</td><td>puntatore ad un dato di tipo uint32_t </td></tr>
    <tr><td class="paramname">out_buffer8</td><td>puntatore ad un dato di tipo uint8_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b6af21578914e5720d4459156b67819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6af21578914e5720d4459156b67819">&#9670;&nbsp;</a></span>Frame8to32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Frame8to32 </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>in_buffer8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>out_buffer32</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converte un frame da un formato uint8_t ad uno uint32_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_buffer8</td><td>puntatore ad un dato di tipo uint8_t </td></tr>
    <tr><td class="paramname">out_buffer32</td><td>puntatore ad un dato di tipo uint32_t </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a261447ba4f7390f2166c325cc68b1129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261447ba4f7390f2166c325cc68b1129">&#9670;&nbsp;</a></span>getSSPin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t getSSPin </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dato l'indirizzo del dispositivo ritorna il pin <a class="el" href="structGPIO.html" title="Stuttura che astrae un device GPIO in kernel-mode. Contiene ciò che è necessario al funzionamento del...">GPIO</a> a cui è collegato il suo slave select. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>indirizzo della periferica SPI </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3a928e23e1c9d3da728ea97d7bb5e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a928e23e1c9d3da728ea97d7bb5e32">&#9670;&nbsp;</a></span>HAL_CAN_RxFifo0MsgPendingCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_CAN_RxFifo0MsgPendingCallback </td>
          <td>(</td>
          <td class="paramtype">CAN_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hcan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback associata alla presenza di un nuovo messaggio pendente nella coda di ricezione 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hcan</td><td>handler alla struttura che gestisce CAN </td></tr>
  </table>
  </dd>
</dl>
<p>Prelevievo di un messaggio dalla FIFO0 di ricezione</p>
<p>Se l'header ricevuto non contiene il campo tipo, il tipo di identificativo e la lunghezza del data bytes attesi</p>
<p>Quando sono stati ricevuti tutti i chunk del messaggio si può procedere con il confronto dei CRC </p>

</div>
</div>
<a id="a9a8bf6971f3659c8ab25324b3833d165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8bf6971f3659c8ab25324b3833d165">&#9670;&nbsp;</a></span>HAL_CAN_TxMailbox0CompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_CAN_TxMailbox0CompleteCallback </td>
          <td>(</td>
          <td class="paramtype">CAN_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hcan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback trasmimssione completata della Mailbox0 di CAN. Indica che tutti i byte che dovevano essere trasmessi dalla mailbox 0 sono stati inviati. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hcan</td><td>handler alla struttura che gestisce CAN </td></tr>
  </table>
  </dd>
</dl>
<p>Viene incrementato il contatore delle callback di trasmissione per gestire l'invio di più </p>

</div>
</div>
<a id="a580f64f5da1d50107c4a73b749550130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580f64f5da1d50107c4a73b749550130">&#9670;&nbsp;</a></span>HAL_GPIO_EXTI_Callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_GPIO_EXTI_Callback </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>GPIO_Pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback associata alla pressione dell'User Button. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GPIO_Pin</td><td>il pin del <a class="el" href="structGPIO.html" title="Stuttura che astrae un device GPIO in kernel-mode. Contiene ciò che è necessario al funzionamento del...">GPIO</a> a cui è collegato il pin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2184443aae265ff78a87a15961ae152d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2184443aae265ff78a87a15961ae152d">&#9670;&nbsp;</a></span>HAL_I2C_ErrorCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_I2C_ErrorCallback </td>
          <td>(</td>
          <td class="paramtype">I2C_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hi2c2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback per errori di comunicazione sul canale I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi2c2</td><td>handler alla struttura che gestisce I2C </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>1- When Slave don't acknowledge it's address, Master restarts communication. 2- When Master don't acknowledge the last data transferred.</p>

</div>
</div>
<a id="aa44a13f1267ff388a3bb8b412fc42149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44a13f1267ff388a3bb8b412fc42149">&#9670;&nbsp;</a></span>HAL_I2C_MasterRxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_I2C_MasterRxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">I2C_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hi2c2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback ricezione completata da parte di un master su I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi2c2</td><td>handler alla struttura che gestisce I2C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a613caac6704693a389560a2c82096d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613caac6704693a389560a2c82096d94">&#9670;&nbsp;</a></span>HAL_I2C_MasterTxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_I2C_MasterTxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">I2C_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hi2c2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback trasmissione completata da parte di un master su I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi2c2</td><td>handler alla struttura che gestisce I2C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a7a3d9a39d359257c383d55a0407b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7a3d9a39d359257c383d55a0407b1b">&#9670;&nbsp;</a></span>HAL_I2C_SlaveRxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_I2C_SlaveRxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">I2C_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hi2c2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback ricezione completata da parte di uno slave su I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi2c2</td><td>handler alla struttura che gestisce I2C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8e6c951b14dd66bc90b9c3c0d3be01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e6c951b14dd66bc90b9c3c0d3be01e">&#9670;&nbsp;</a></span>HAL_I2C_SlaveTxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_I2C_SlaveTxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">I2C_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hi2c2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback trasmissione completata da parte di uno slave su I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi2c2</td><td>handler alla struttura che gestisce I2C </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae71c29e701768afa55489b6dcc7d687f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71c29e701768afa55489b6dcc7d687f">&#9670;&nbsp;</a></span>HAL_SPI_ErrorCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_SPI_ErrorCallback </td>
          <td>(</td>
          <td class="paramtype">SPI_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hspi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback per errori di comunicazione sul canale SPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hspi</td><td>handler alla struttura che gestisce SPI </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c4eea7120c00e97f8ce73e23cc3e81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4eea7120c00e97f8ce73e23cc3e81f">&#9670;&nbsp;</a></span>HAL_SPI_RxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_SPI_RxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">SPI_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hspi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback ricezione completata sul canale SPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hspi</td><td>handler alla struttura che gestisce SPI </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d5a443b4169f49e381dda4bbe265aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5a443b4169f49e381dda4bbe265aeb">&#9670;&nbsp;</a></span>HAL_SPI_TxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_SPI_TxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">SPI_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>hspi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback trasmissione completata sul canale SPI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hspi</td><td>handler alla struttura che gestisce SPI </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a945d8c6ae6e925d17599d96449e831d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945d8c6ae6e925d17599d96449e831d9">&#9670;&nbsp;</a></span>HAL_UART_ErrorCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_UART_ErrorCallback </td>
          <td>(</td>
          <td class="paramtype">UART_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>UartHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback per errori di comunicazione sul canale <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UartHandle</td><td>handler alla struttura che gestisce <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fc70122d6af8fd1cfd4d515ca68192a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc70122d6af8fd1cfd4d515ca68192a">&#9670;&nbsp;</a></span>HAL_UART_RxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_UART_RxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">UART_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>UartHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback ricezione completata sul canale <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UartHandle</td><td>handler alla struttura che gestisce <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7c3eb59acb57cee8fe62f1ba0c10c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7c3eb59acb57cee8fe62f1ba0c10c6">&#9670;&nbsp;</a></span>HAL_UART_TxCpltCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HAL_UART_TxCpltCallback </td>
          <td>(</td>
          <td class="paramtype">UART_HandleTypeDef *&#160;</td>
          <td class="paramname"><em>UartHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback trasmissione completata sul canale <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">UartHandle</td><td>handler alla struttura che gestisce <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae20365087f09118bf9f8ceca48ac9f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20365087f09118bf9f8ceca48ac9f26">&#9670;&nbsp;</a></span>Receive_CRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Receive_CRC </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ReceivedData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abilita la ricezione del frame sulle periferiche selezionate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ReceivedData</td><td>struttura contenete i dati ricevuti </td></tr>
    <tr><td class="paramname">channel</td><td>indica le periferiche da cui effettuare la ricezione </td></tr>
    <tr><td class="paramname">address</td><td>indica lo slave SPI con cui voglio comunicare, permettendo di scegliere lo slave select opportuno </td></tr>
  </table>
  </dd>
</dl>
<p>La ricezione è effettuata chiamando la seguente funzione, passando l'<a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a> handler, un puntatore al buffer in cui salvare il messaggio ricevuto e la sua dimensione</p>
<p>Il programma attende finchè il valore della variabile UartReady è RESET. All'avvenuto completamento della ricezione la callback HAL_UART_RxCpltCallback setterà il valore permettendo di avanzare con l'esecuzione</p>
<p>Le funzioni fornite dall'Hardware Abstraction Layer per la trasmissione e ricezione utilizzano buffer da 8 bit. E' necessario dunque riconvertire il messaggio ricevuto, contenuto in un buffer di BUFFER_SIZE valori da 8 bit in un buffer contenente FRAME_SIZE valori da 32 bit</p>
<p>La seguente chiamata provvede a ricalcolare i due CRC dal payload del messggio ricevuto e a confrontarli con quelli contenuti nel messaggio. Queste ultime due chiamate vengono ripetute esattamente nelle successive sezioni relative alle altre periferiche.</p>
<p>Il programma attende finchè lo stato di I2C non è uguale a READY</p>
<p>La ricezione su CAN è effettuata nella callback relativa all'avvenuta ricezione. Vedi documentazione esterna</p>
<p>L'indirizzo del nodo dal quale si vuole ricevere viene utilizzato dal master per calcolare quale Slave Select deve essere deasserito per selezionare lo slave dal quale si vuole ricevere</p>
<p>Se la board non è master prima di poter effettuare la ricezione è necessario attendere che il master porti al valore basso lo Slave Select</p>
<p>Il programma attende che la trasmissione sia completa. All'avvenuto completamento della ricezione la callback HAL_SPI_RxCpltCallback setterà il valore dello stato a TRANSFER_COMPLETE permettendo di avanzare con l'esecuzione</p>
<p>Viene riportato al valore alto lo Slave Select e resettato il valore dello stato </p>

</div>
</div>
<a id="a8049f589625aaa8ae0520981ab7ce83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8049f589625aaa8ae0520981ab7ce83c">&#9670;&nbsp;</a></span>Send_CRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Send_CRC </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>MSG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invia il messaggio sulle varie periferiche. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">MSG</td><td>messaggio da inviare </td></tr>
    <tr><td class="paramname">address</td><td>indirizzo della periferica da contattare se previsto dalla modalità di comunicazione </td></tr>
    <tr><td class="paramname">channel</td><td>indica le periferiche sulle queli effettuare la trasmissione </td></tr>
  </table>
  </dd>
</dl>
<p>Viene effettuato il controllo sulla compatibilità della modalità di trasmissione scelta e i canali selezionati</p>
<p>Attesa di pressione User Button</p>
<p>Le funzioni fornite dall'Hardware Abstraction Layer per la trasmissione e ricezione utilizzano buffer da 8 bit. E' necessario dunque convertire il messaggio originale, contenuto in un buffer di FRAME_SIZE valori da 32 bit, in un buffer contenente BUFFER_SIZE valori da 8 bit</p>
<p>Se è stata richiesta la trasmissione sul canale <a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a> viene effettuata la trasmissione</p>
<p>La trasmissione è effettuata chiamando la seguente funzione, passando l'<a class="el" href="structUART.html" title="Stuttura che astrae un device UART in kernel-mode. Contiene ciò che è necessario al funzionamento del...">UART</a> handler, un puntatore al buffer contenente il messaggio da trasmettere e la sua dimensione</p>
<p>Il programma attende finchè il valore della variabile UartReady è RESET. All'avvenuto completamento della trasmissione la callback HAL_UART_TxCpltCallback setterà il valore permettendo di avanzare con l'esecuzione</p>
<p>Viene aggiornato il parametro relativo ai canali sui quali è terminata la trasmissione</p>
<p>Se l'errore di trasmissione è dato dal mancato ack da parte dello slave esso viene ignorato</p>
<p>Il programma attende finchè lo stato di I2C non è uguale a READY</p>
<p>Standard CAN Identifier: identificativo del messaggio codificato su 11 bit secondo il protocollo CAN Standard</p>
<p>Extended CAN Identifier: identificativo del messaggio codificato su 29 bit secondo il protocollo CAN Extended</p>
<p>Tipo di messaggio</p>
<p>Tipo di identificativo per il messaggio da trasmettere: Standard o Extended</p>
<p>Lunghezza in byte del messaggio da trasmettere. Può assumere un valore da 0 ad 8</p>
<p>Timestamp acquisito all'avvio della trasmissione del Frame. Se abilitato viene aggiunto al messaggio.</p>
<p>Dal momento che il campo Data Bytes del frame CAN, ovvero il messaggio da trasmettere, può essere massimo di 8 bytes vengono effettuate più chiamate alla funzione HAL_CAN_AddTxMessage. Questa prende in ingresso l'handler di CAN, l'header del messaggio appena costruito e un buffer contenente dati di 8 bit. Ha il compito di aggiungere il messaggio alla prima mailbox di trasmissione che rileva libera. L'identificativo della mailbox nella quale ha deposto il messaggio viene ritornato mediante il parametro TxMailbox</p>
<p>Quando è stato eseguito un numero di callback di trasmissione che indica l'avvenuto trasferimento di tutti i chunk da 8 bytes trasmessi, viene aggiornato il parametro relativo ai canali sui quali è terminata la trasmissione</p>
<p>L'indirizzo del nodo destinazione viene utilizzato per calcolare quale Slave Select deve essere deasserito per selezionare lo slave al quale si vuole trasmettere il messaggio</p>
<p>Se la board non è master prima di poter effettuare la trasmissione è necessario attendere che il master porti al valore basso lo Slave Select</p>
<p>Il programma attende che il trasferimento sia completo. All'avvenuto completamento della trasmissione, la callback HAL_SPI_TxCpltCallback setterà il valore dello stato a TRANSFER_COMPLETE permettendo di avanzare con l'esecuzione</p>
<p>Viene riportato al valore alto lo Slave Select e resettato il valore dello stato </p>

</div>
</div>
<a id="a70af21c671abfcc773614a9a4f63d920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70af21c671abfcc773614a9a4f63d920">&#9670;&nbsp;</a></span>SystemClock_Config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SystemClock_Config </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gestisce il clock di sistema. </p>
<p>Initializes the CPU, AHB and APB busses clocks</p>
<p>Initializes the CPU, AHB and APB busses clocks </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a35bb3a59effda30f42642a9d9991e604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bb3a59effda30f42642a9d9991e604">&#9670;&nbsp;</a></span>Frame</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Frame[FRAME_SIZE]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Messaggio da trasmettere </p>

</div>
</div>
<a id="a1ed6966985e75bef763d646515dc9814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed6966985e75bef763d646515dc9814">&#9670;&nbsp;</a></span>rx_callback_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rx_callback_count = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contatore della Callback di ricezione tramite CAN </p>

</div>
</div>
<a id="a507c4baeac0bd2ecf2adbf1c337f0bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507c4baeac0bd2ecf2adbf1c337f0bb9">&#9670;&nbsp;</a></span>tx_callback_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tx_callback_count = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contatore delle Callback di trasmissione tramite CAN </p>

</div>
</div>
<a id="a5b134fe1bc9546c6dfe5b5c937e0ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b134fe1bc9546c6dfe5b5c937e0ece5">&#9670;&nbsp;</a></span>UART_RxBuffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t UART_RxBuffer[BUFFER_SIZE]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer utilizzati per gestire le trasmissioni e le ricezioni su ogni protocollo </p>

</div>
</div>
<a id="ab25c9d3b737ed7a30c037e77439e496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25c9d3b737ed7a30c037e77439e496e">&#9670;&nbsp;</a></span>UserButtonStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__IO uint32_t UserButtonStatus = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Settato a 1 dopo la ricezione dell'interruzione scatenata dalla pressione dell' User Button </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
