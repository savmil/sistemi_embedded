#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\begin_preamble
\usepackage{listings,xcolor,courier,bookmark,float}
\usepackage{listingsutf8}
\definecolor{darkblue}{named}{blue}
\definecolor{darkred}{named}{red}
\definecolor{grau}{named}{gray}
\let\Righttorque\relax
\lstset{
captionpos=b,
commentstyle=\color[rgb]{0.133,0.545,0.133},
keywordstyle=\color{darkblue},
stringstyle=\color{darkred},
extendedchars=true,
basicstyle=\small\ttfamily,
showstringspaces=false,
tabsize=2,
numbers=left,
numberstyle=\tiny,
breakautoindent  = true,
breakindent      = 2em,
breaklines       = true,
postbreak        = ,
prebreak         = \raisebox{-.8ex}[0ex][0ex]{\Righttorque},
showspaces=false, 
showtabs=false, 
showstringspaces=false,
language=VHDL,
frame=single,
morecomment=[s]{--}
}


\renewcommand*{\lstlistingname}{Codice Componente}


\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead{} 
\fancyfoot{} 

\fancyhead[RO,LE]{\bfseries \leftmark}
\fancyfoot[LE,RO]{\thepage}
\fancyfoot[LO,CE]{Tesina in ASE: Architetture dei Sistemi di Elaborazione}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\date{}
\cfoot{}
\end_preamble
\use_default_options true
\master Tesina.lyx
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2.5cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Soluzione
\end_layout

\begin_layout Subsection
Dispostivo UART
\end_layout

\begin_layout Standard
L'implementazione del componente UART è stata realizatta seguendo lo schema
 di un generico dispositivo commerciale, dividendo dunque la logica nei
 seguenti blocchi (Figura 0.1):
\end_layout

\begin_layout Itemize
sezione ricevitore: implementa la logica di ricezione.
 Quanto un byte è ricevuto viene copiato nell'Holding Register e vi rimane
 fino alla completa riecezione del successivo byte.
 Al completamento della ricezione il segnale 
\series bold
RDA
\series default
 viene asserito fino all'inizio di una successiva ricezione.
\end_layout

\begin_layout Itemize
sezione trasmettitore: implementa la logica di trasmissione.
 Il trasferimento viene abilitato asserendo il segnale 
\series bold
TX_ENABLE.
 
\series default
All'inizio dell'trasferimento il segnale tx_busy diviene attivo e vi resta
 fino alla fine del trasferimento.
 Per questione di temporizzazione è necessario che il segnale di enable
 del trasferimento sia un pulse in modo che ritorni automaticamente al valore
 basso, evitando un nuovo ciclo di trasferimento involontario.
 Dunque viene utilizzato il componente Level to Pulse che prende in ingresso
 il segnale di enable esterno e sul rising edge di quest'ultimo produce
 in uscita un pulse.
\end_layout

\begin_layout Itemize
modulazione del clock: componente che prende in ingresso il clock esterno
 e adegua i clock dei componenti interni per rispettare le velocità imposte
 dal protocollo.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/uart.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Schema a blocchi componente UART
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con riferimento alla Figura 0.1, si stabilisca la seguente convezione: i
 segnali in grasseto rappresentano l'interfaccia del componente, quelli
 sulla sinistra indicano segnali di ingresso, quelli sulla desta di uscita.
 Alcuni sengali (clock, reset), avento multiple destinazioni, non sono collegati
 per pura questione di visibiltà.
\end_layout

\begin_layout Subsubsection
Sezione Trasmissione
\end_layout

\begin_layout Itemize
Shift Register con scorrimento a destra, caricamento parallelo del dato
 da trasmettere ed uscita seriale per la trasmissione sul canale.
\end_layout

\begin_layout Itemize
Contatore Mod 11 incrementato ad ogni bit trasmesso il cui segnale di uscita
 counter_done viene utilizzato dalla control unit per verificare la fine
 della trasmissione.
\end_layout

\begin_layout Itemize
Macchina a stati finiti che implementa la logica di trasmissione del protocollo.
 Segue un grafo degli stati per descriverne il funzionamento:
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/tx_fsm.png
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Diagramma Stati FSM trasferimento
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il sengale di reset forza la macchina nello stato di idle.
\end_layout

\begin_layout Subsubsection
Sezione Ricezione
\end_layout

\begin_layout Itemize
Shift Register con scorrimento a destra, ingresso seriale del bit ricevuto
 ed uscita parallela.
 Si è scelto di connettere l'uscita direttamente ad un Holding Register
 esterno, il quale viene abilitato dalla FSM solo a ricezione completata
 e successivamente disabilitato per preservare il dato fino all'arrivo dei
 successivo
\end_layout

\begin_layout Itemize
Porte XOR per il calcolo del bit di parità e verifica integrità del frame.
\end_layout

\begin_layout Itemize
Contatore Mod 8 utilizzato all'inizio della ricezione per lo sfasamento
 necessario per effettuare il campionamento della linea di ingresso al centro
 del bit.
\end_layout

\begin_layout Itemize
Contatore Mod 16 utilizzato per il campionamento dei bit.
\end_layout

\begin_layout Itemize
Contatore Mod 10 utilizzato per tenere traccia del numero dei bit già ricevuti.
 Dimensionato a 10 in quanto non viene memorizzato il bit di start.
\end_layout

\begin_layout Itemize
Macchina a stati finiti che implementa la logica di ricezione del protocollo.
 Segue un grafo degli stati per descriverne il funzionamento:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/unart_rx_cu.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si è scelto, per questioni di temporizzazione e per fornire un modello di
 programmazione adeguato, aggiungere uno stato rda_state.
 Questo perchè quando il carattere è stato ricevuto completatamente si passa
 dallo stato get_bit a quello check_stop dove viene dato l'enable dell'holding
 register nel quale verrà copiato il dato.
 Dunque ci si riserva un ciclo di clock per effettuare questa operazione
 e dare RDA nello stato successivo quando il dato è già stato copiato nell'holdi
ng register.
 Naturalmente, il segnale di reset forza la macchina a tornare nello stato
 idle.
\end_layout

\begin_layout Subsubsection
Modulazione del Clock
\end_layout

\begin_layout Standard
Il componente UART prende in ingresso due parametri Generic che indicano
 il Baud Rate e la frequenza del clock che fa da base dei tempi.
 È stato realizzato un componete Clock Mod che rallenta la frequenza di
 ingresso del doppio del parametro dato in ingresso dal Generic.
 Il seguente componente, con parametri differenti è stato utilizzato sia
 per il Baud Rate sia per gestire la diversa tempificazione di ricevitore
 e trasmettitore a partire dalla stessa base dei tempi.
\end_layout

\begin_layout Itemize
Baud Generator: prende in ingresso la costante BaudDivide, calcolata come
 
\begin_inset Formula $BaudDivide=\frac{freq_{in}}{BaudRate*16*2}$
\end_inset


\end_layout

\begin_layout Itemize
Tx clock Mod: prende in ingresso 8 per far sì che la frequenza del clock
 del trasmettitore sia 16 volte più lenta di quella del ricevitore.
\end_layout

\begin_layout Subsection
Custom AXI IP Core
\end_layout

\begin_layout Standard
Si procede dunque alla crazione di un costum IP Core come mostrato nel precedent
e capitolo.
 Verranno instanziati due componenti:
\end_layout

\begin_layout Enumerate

\series bold
my_uart_intv1
\series default
: top modul dell'IP.
 Il segnale TX è in out all'ip mentre quello di RX in ingresso.
\end_layout

\begin_layout Enumerate

\series bold
my_uart_int_v1_0_S00_AXI
\series default
: si occupa dell'interfacciamento del componente 
\series bold
UART
\series default
 con il bus per la logica di trasmissione da e verso il processore.
 Intefaccia i segnali TX e RX dal componente UART al top modul.
 Gestisce i la logica di interruzione della periferica
\end_layout

\begin_layout Subsubsection

\series bold
my_uart_int_v1_0_S00_AXI
\end_layout

\begin_layout Standard
Segue una tabella degli indirizzi dei registri utilizzati dal componente
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nome
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Map bit->segnali
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
DIR
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TX_DATA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TX_DATA[7...0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TX_ENABLE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TX_EN[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UART_STATUS_REG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TX_BUSY[4] RDA[3] PE[2] FE[1] OE[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RX_DATA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RX_DATA[7..0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GLOBAL_INT_ENALBE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GBL_INT_EN[0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INT_ENABLE_MASK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INT_MASK[1..0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
W
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PENDING_INT/ACK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
INTR_PEND[1..0]/ACK[1..0]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
R/W
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Mapping indirizzi
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si omette la connessione del componente UART in quanto basilare e riassumibile
 tramite la Tabella 0.1.
 Il componente genera il segnale di interrupt se è stato completato il trasferim
ento di un carattere (falling edge di TX_BUSY) oppure se ne è stata completata
 la ricezione (rising edge di RDA).
 Si mostra la porzione di codice VHDL che consente la rilevazione di una
 delle due condizioni.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=VHDL]     
\end_layout

\begin_layout Plain Layout

    --! process utilizzato per captare varizione dei segnali RDA(bit 3)
 e tx_busy(bit 4)
\end_layout

\begin_layout Plain Layout

    --! la sintesi da due FF in cascata
\end_layout

\begin_layout Plain Layout

    status_reg_sampling : process (S_AXI_ACLK,uart_status_reg)
\end_layout

\begin_layout Plain Layout

    begin
\end_layout

\begin_layout Plain Layout

    if (rising_edge (S_AXI_ACLK)) then
\end_layout

\begin_layout Plain Layout

        if ( S_AXI_ARESETN = '0' ) then
\end_layout

\begin_layout Plain Layout

            last_stage <= (others => '0');
\end_layout

\begin_layout Plain Layout

            current_stage <= (others => '0');
\end_layout

\begin_layout Plain Layout

        else
\end_layout

\begin_layout Plain Layout

            last_stage <= uart_status_reg(4 downto 3);
\end_layout

\begin_layout Plain Layout

            current_stage <= last_stage; 
\end_layout

\begin_layout Plain Layout

        end if;    
\end_layout

\begin_layout Plain Layout

    end if;
\end_layout

\begin_layout Plain Layout

    end process;
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    tx_busy_falling_detect <= not last_stage(1) and  current_stage(1); 
   --! detect falling edge tx_busy
\end_layout

\begin_layout Plain Layout

    rx_rising_detect <= not current_stage(0) and last_stage(0);        
   --! detect rising edge RDA
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	changed_bits <= (rx_rising_detect & tx_busy_falling_detect) and intr_mask;
 --! and con la intr_mask perchè sono interessato a vedere l'edge del sengale
\end_layout

\begin_layout Plain Layout

                                                                       
        --! solo se la relativa interruzione è abilitata   
\end_layout

\begin_layout Plain Layout

   
\end_layout

\begin_layout Plain Layout

    change_detected <= global_intr and or_reduce(changed_bits);        
        --! Segnale che indica se è stato rilevata una variazione di tx_busy
 o RDA 
\end_layout

\begin_layout Plain Layout

                                                                       
        --! alla quale si è interessati    
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Siamo interessati a rilevare uno dei due edge solo se è stato richiesto
 che il componente lavori con le interruzioni (GLOBAL_INTR_EN) e le due
 linee di interruzione sono abilitate (INTR_MASK).
 Segue il process di gestione delle interruzioni pendendi e dell'ack.
 Se viene rilevata una nuova richiesta di interruzione su una delle due
 linee essa viene aggiunta alle precedenti pendenti.
 Se viene dato un ack per la specifica interruzione essa viene rimossa da
 quelle pendenti.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=VHDL]     
\end_layout

\begin_layout Plain Layout

   --! delay del segnale pending_intr
\end_layout

\begin_layout Plain Layout

   	 pending_intr_tmp <= pending_intr;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    --! process per la gestizione della logica di interruzione pedente 
\end_layout

\begin_layout Plain Layout

    --! e meccanismo di ack per rimuovere l'interruzione pendente
\end_layout

\begin_layout Plain Layout

    intr_pending : process (S_AXI_ACLK, change_detected, ack_intr)
\end_layout

\begin_layout Plain Layout

    begin
\end_layout

\begin_layout Plain Layout

    if (rising_edge (S_AXI_ACLK)) then
\end_layout

\begin_layout Plain Layout

        if (change_detected = '1') then                                
        --! se c'è richiesta di interruzione su una delle due line
\end_layout

\begin_layout Plain Layout

            pending_intr <= pending_intr_tmp or changed_bits;          
        --! aggiungi la richiesta alle interruzioni pendenti
\end_layout

\begin_layout Plain Layout

        else
\end_layout

\begin_layout Plain Layout

            if (or_reduce(ack_intr)='1') then                          
        --! se viene dato un ack
\end_layout

\begin_layout Plain Layout

                pending_intr <= pending_intr_tmp and (not ack_intr);   
        --! rimuovi la richiesta pendente relativa
\end_layout

\begin_layout Plain Layout

            end if;   
\end_layout

\begin_layout Plain Layout

        end if;   
\end_layout

\begin_layout Plain Layout

    end if;
\end_layout

\begin_layout Plain Layout

    end process;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Segue il codice per la gestione dell'unico segnale di interrupt uscende
 dall'IP Core.
 Quale delle due linee interne ha generato la richiesta di interruzione
 alla CPU dovrà essere verificato tramite software
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout


\backslash
begin{lstlisting}[language=VHDL]     
\end_layout

\begin_layout Plain Layout

	--! process per gestire l'unica linea di interruzione 
\end_layout

\begin_layout Plain Layout

	 --! in unscita dal componente
\end_layout

\begin_layout Plain Layout

    inst_irq : process(S_AXI_ACLK,pending_intr)
\end_layout

\begin_layout Plain Layout

    begin
\end_layout

\begin_layout Plain Layout

        if (rising_edge (S_AXI_ACLK)) then
\end_layout

\begin_layout Plain Layout

            if ( S_AXI_ARESETN = '0' ) then
\end_layout

\begin_layout Plain Layout

                    interrupt <= '0';
\end_layout

\begin_layout Plain Layout

            else
\end_layout

\begin_layout Plain Layout

                if (or_reduce(pending_intr) = '1') then                
        --! Se c'è almeno un interruzione pendente
\end_layout

\begin_layout Plain Layout

                    interrupt <= '1';                                  
        --! interrupt = '1'
\end_layout

\begin_layout Plain Layout

                else
\end_layout

\begin_layout Plain Layout

                    interrupt <= '0';                                  
        --! altrimenti 0
\end_layout

\begin_layout Plain Layout

                end if;
\end_layout

\begin_layout Plain Layout

            end if;
\end_layout

\begin_layout Plain Layout

        end if;
\end_layout

\begin_layout Plain Layout

    end process;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Design
\end_layout

\begin_layout Standard
Per testare il componente, la linea TX è stata collegata alla linea RX allaccian
do il componente su se stesso.
 Dunque ad ogni trasmissione corrisponderà una ricezione.
\end_layout

\end_body
\end_document
